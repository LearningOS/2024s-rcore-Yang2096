
## 课后问答
1. * 如何查看Linux操作系统中的进程？
	- ps -ef
    
2. * 简单描述一下进程的地址空间中有哪些数据和代码。
	- 数据：程序的 .data \\ .rodata ，TrapContext
	- 代码：程序的 .text，跳板内的操作系统不同特权级的跳转代码

3. * 进程控制块保存哪些内容？
	- 程序的地址空间，内核栈地址，TaskContext，exit_code
    
4. * 进程上下文切换需要保存哪些内容？
	- 页表 token，内核栈 sp
    
5. ** fork 为什么需要在父进程和子进程提供不同的返回值？
	- 用于区分接下来的执行中是父进程还是子进程
    
6. ** fork + exec 的一个比较大的问题是 fork 之后的内存页/文件等资源完全没有使用就废弃了，针对这一点，有什么改进策略？
	- 写时复制策略，在两边都没有改动实际物理内存时保持页表项不动

8. ** 其实使用了6的策略之后，fork + exec 所带来的无效资源的问题已经基本被解决了，但是近年来fork 还是在被不断的批判，那么到底是什么正在”杀死”fork？可以参考 [论文](https://www.microsoft.com/en-us/research/uploads/prod/2019/04/fork-hotos19.pdf) 。
    
8. ** 请阅读下列代码，并分析程序的输出，假定不发生运行错误，不考虑行缓冲，不考虑中断：
    
    > int main(){
    >     int val = 2;
    > 
    >     printf("%d", 0);
    >     int pid = fork();
    >     if (pid == 0) {
    >         val++;
    >         printf("%d", val);
    >     } else {
    >         val--;
    >         printf("%d", val);
    >         wait(NULL);
    >     }
    >     val++;
    >     printf("%d", val);
    >     return 0;
    > }

9. 如果 fork() 之后主程序先运行，则结果如何？如果 fork() 之后 child 先运行，则结果如何？
	- 主程序先运行：0， 1， 2，3，4
	- child 先运行：0，3，4，1，2

9. ** 为什么子进程退出后需要父进程对它进行 wait，它才能被完全回收？
	- 需要收集子进程的 exit_code
    
10. ** 有哪些可能的时机导致进程切换？
	- 时钟中断、程序主动 yield、系统调用阻塞
    
11. ** 请描述在本章操作系统中实现本章提出的某一种调度算法（RR调度除外）的简要实现步骤。
    
12. * 非抢占式的调度算法，以及抢占式的调度算法，他们的优点各是什么？
    
13. ** 假设我们简单的将进程分为两种：前台交互（要求短时延）、后台计算（计算量大）。下列进程/或进程组分别是前台还是后台？a) make 编译 linux; b) vim 光标移动; c) firefox 下载影片; d) 某游戏处理玩家点击鼠标开枪; e) 播放交响乐歌曲; f) 转码一个电影视频。除此以外，想想你日常应用程序的运行，它们哪些是前台，哪些是后台的？
	- 前台：b, d, e
	- 后台：a, c, f
    
14. ** RR 算法的时间片长短对系统性能指标有什么影响？
	- 时间片越短，系统响应时间越小，平均周转时间则会越大
    
15. ** MLFQ 算法并不公平，恶意的用户程序可以愚弄 MLFQ 算法，大幅挤占其他进程的时间。（MLFQ 的规则：“如果一个进程，时间片用完了它还在执行用户计算，那么 MLFQ 下调它的优先级”）你能举出一个例子，使得你的用户程序能够挤占其他进程的时间吗？
	- 故意在时间片快用完的时候让出 CPU
    
16. *** 多核执行和调度引入了哪些新的问题和挑战？
	- 多核之间数据同步的问题
	- 多核下调度算法的设计