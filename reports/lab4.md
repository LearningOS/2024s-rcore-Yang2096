
## 课后问答
1. * 在使用高级语言编写用户程序的时候，手动用嵌入汇编的方法随机访问一个不在当前程序逻辑地址范围内的地址，比如向该地址读/写数据。该用户程序执行的时候可能会生什么？
	- 段错误
    
2. * 用户程序在运行的过程中，看到的地址是逻辑地址还是物理地址？从用户程序访问某一个地址，到实际内存中的对应单元被读/写，会经过什么样的过程，这个过程中操作系统有什么作用？（站在学过计算机组成原理的角度）
	- 逻辑地址
	- 会经过虚拟地址到物理地址的转化，涉及 TLB 的查询、MMU对页表的查找、缺页中断的处理等过程。操作系统维护了页表，也即虚拟内存在物理内存中的状态
    
3. * 覆盖、交换和虚拟存储有何异同，虚拟存储的优势和挑战体现在什么地方？
	- 
    
4. * 什么是局部性原理？为何很多程序具有局部性？局部性原理总是正确的吗？为何局部性原理为虚拟存储提供了性能的理论保证？
	- 空间局部性：现在被访问到的内存，其周边的内存也大概率会被访问到
	- 时间局部性：现在被访问到的内存，在未来也大概率会被再次访问
	- 之所以程序具备局部性，应该是因为程序一般都是线性执行的，操作的内存位置相对较为固定
	- 局部性原理使得程序一段时间内访问的页面限制在少数的几个中，可以被 cache 缓存到，因而获得了较好的访存速度
    
5. ** 一条load指令，最多导致多少次页访问异常？尝试考虑较多情况。
    
6. ** 如果在页访问异常中断服务例程执行时，再次出现页访问异常，这时计算机系统（软件或硬件）会如何处理？这种情况可能出现吗？
	- 内核嵌套处理缺页异常？
    
7. * 全局和局部置换算法有何不同？分别有哪些算法？
    
8. * 简单描述OPT、FIFO、LRU、Clock、LFU的工作过程和特点 (不用写太多字，简明扼要即可)
    - OPT：最优的置换算法，由于需要参考未来的访存信息，所以不可能实现，只能作为 benchmark
    - FIFO：每次需要换出页面时，换出最早载入的内存页，缺少局部性的考虑
    - LRU：需要记录内存页被访问的次数，以此排序，换出最少被访问的内存页
    - Clock：访问时置位页表项，循环检查时碰到访问过的内存就将其置为 0，碰到上一次循环检查后没有访问过的（位为 0 的）内存就换出
1. ** 综合考虑置换算法的收益和开销，综合评判在哪种程序执行环境下使用何种算法比较合适？
    
10. ** Clock算法仅仅能够记录近期是否访问过这一信息，对于访问的频度几乎没有记录，如何改进这一点？
    
11. *** 哪些算法有belady现象？思考belady现象的成因，尝试给出说明OPT和LRU等为何没有belady现象。
    
12. * 什么是工作集？什么是常驻集？简单描述工作集算法的工作过程。
	- 工作集：在程序执行的任一时刻，都存在一个动态变化的页面集合，它包含所有最近内存访问所访问过的页面。
	- 常驻集：即当前时刻，任务实际驻留在内存中的页面集合。
    
13. * 请列举 SV39 页`*` 页表项的组成，结合课堂内容，描述其中的标志位有何作用／潜在作用？
    
14. ** 请问一个任务处理 10G 连续的内存页面，需要操作的页表实际大致占用多少内存(给出数量级即可)？
	- 10G = 4K * 5 * 1024 * 512
	- 即 5 * 1024 * 512 个页表项，5 * 1024 个二级页表项，10 个一级页表项 ~ 20MB
    
15. ** 缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断，告知操作系统：该进程内存访问出了问题。然后操作系统可选择填补页表并重新执行异常指令或者杀死进程。操作系统基于缺页异常进行优化的两个常见策略中，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 操作系统并不会马上这样做，而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。 另一个常见策略是 swap 页置换策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效，操作系统在任务访问到该页产生异常时，再把数据从磁盘加载到内存。

    - 哪些异常可能是缺页导致的？发生缺页时，描述与缺页相关的CSR寄存器的值及其含义。
        
    - Lazy 策略有哪些好处？请描述大致如何实现Lazy策略？
		- 启动快、省内存
		- 在页表项中存储磁盘扇区信息        
    - swap 页置换策略有哪些好处？此时页面失效如何表现在页表项(PTE)上？请描述大致如何实现swap策略？
		- PTE 的存在位（Present Bit）置“0”
		
16. ** 为了防范侧信道攻击，本章的操作系统使用了双页表。但是传统的操作系统设计一般采用单页表，也就是说，任务和操作系统内核共用同一张页表，只不过内核对应的地址只允许在内核态访问。(备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 [KPTI](https://en.wikipedia.org/wiki/Kernel_page-table_isolation) )
    
    - 单页表情况下，如何控制用户态无法访问内核页面？
	    - 设置内核页面的访问属性，不设置 U 权限
        
    - 相对于双页表，单页表有何优势？
	    - 更少的 TLB 缓存失效
        
    - 请描述：在单页表和双页表模式下，分别在哪个时机，如何切换页表？
	    - 双页表需要在 trap 进入、退出 时切换到 内核、用户 页表
	    - 单页表需要在任务切换时切换页表

